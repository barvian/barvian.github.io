{"version":3,"sources":["barvian.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","window","matchMedia","styleMedia","media","style","document","createElement","script","getElementsByTagName","info","type","id","parentNode","insertBefore","getComputedStyle","currentStyle","matchMedium","text","styleSheet","cssText","textContent","width","matches","w","doc","image","expose","picturefill","define","amd","opt","elements","element","parent","firstMatch","candidates","options","pf","getAllElements","plen","undefined","nodeName","toUpperCase","ns","reevaluate","evaluated","removeVideoShim","getMatch","sizesSupported","srcset","regWDesc","test","dodgeSrcset","processSourceSet","applyBestCandidate","runPicturefill","checkResize","clearTimeout","resizeTimer","setTimeout","handleResize","initTypeDetects","intervalId","setInterval","readyState","clearInterval","addEventListener","attachEvent","HTMLPictureElement","srcsetSupported","curSrcSupported","trim","str","replace","makeUrl","anchor","src","href","restrictsMixedContent","location","protocol","matchesMedia","getDpr","devicePixelRatio","getWidthFromLength","cssValue","indexOf","parseFloat","lengthEl","className","body","appendChild","offsetWidth","removeChild","detectTypeSupport","typeUri","Image","onerror","types","onload","implementation","hasFeature","verifyTypeSupport","source","getAttribute","pfType","parseSize","sourceSizeStr","match","exec","findWidthFromSourceSize","sourceSizeListStr","winningLength","sourceSizeList","split","len","sourceSize","parsedSize","Math","max","innerWidth","documentElement","clientWidth","parseSrcset","url","pos","search","descriptor","slice","last","descpos","push","parseDescriptor","sizesattr","resCandidate","sizes","sizeDescriptor","widthInCssPixels","splitDescriptor","curr","lastchar","res","isNaN","parseInt","getCandidatesFromSourceSet","formattedCandidates","candidate","resolution","img","setAttribute","el","backfaceVisibilityFix","picImg","WebkitBackfaceVisibility","currentZoom","zoom","setIntrinsicSize","urlCache","setSize","bestCandidate","pfStopIntrinsicSize","dims","sort","ascendingSort","substr","toLowerCase","console","warn","currentSrc","b","picture","videos","video","vsources","elems","imgs","h","currImg","sources","childNodes","j","slen","nodeType","typeSupported","_",2,"_interopRequireDefault","obj","__esModule","default","_picturefill","../variables","./../bower_components/picturefill/dist/picturefill.js",3,"breakpoints","alpha","bravo","charlie","short"],"mappings":"CAAA,QAAUA,GAAEC,EAAEC,EAAEC,GAAG,QAASC,GAAEC,EAAEC,GAAG,IAAIJ,EAAEG,GAAG,CAAC,IAAIJ,EAAEI,GAAG,CAAC,GAAIE,GAAkB,kBAATC,UAAqBA,OAAQ,KAAIF,GAAGC,EAAE,MAAOA,GAAEF,GAAE,EAAI,IAAGI,EAAE,MAAOA,GAAEJ,GAAE,EAAI,IAAIK,GAAE,GAAIC,OAAM,uBAAuBN,EAAE,IAAK,MAAMK,GAAEE,KAAK,mBAAmBF,EAAE,GAAIG,GAAEX,EAAEG,IAAIS,WAAYb,GAAEI,GAAG,GAAGU,KAAKF,EAAEC,QAAQ,SAASd,GAAG,GAAIE,GAAED,EAAEI,GAAG,GAAGL,EAAG,OAAOI,GAAEF,EAAEA,EAAEF,IAAIa,EAAEA,EAAEC,QAAQd,EAAEC,EAAEC,EAAEC,GAAG,MAAOD,GAAEG,GAAGS,QAAkD,IAAI,GAA1CL,GAAkB,kBAATD,UAAqBA,QAAgBH,EAAE,EAAEA,EAAEF,EAAEa,OAAOX,IAAID,EAAED,EAAEE,GAAI,OAAOD,KAAKa,GAAG,SAAST,EAAQU,EAAOJ;;;;AAMvdK,OAAOC,aAAeD,OAAOC,WAAa,WACzC,YAGA,IAAIC,GAAcF,OAAOE,YAAcF,OAAOG,KAG9C,KAAKD,EAAY,CAChB,GAAIE,GAAcC,SAASC,cAAc,SACxCC,EAAcF,SAASG,qBAAqB,UAAU,GACtDC,EAAc,IAEfL,GAAMM,KAAQ,WACdN,EAAMO,GAAQ,oBAEdJ,EAAOK,WAAWC,aAAaT,EAAOG,GAGtCE,EAAQ,oBAAsBT,SAAWA,OAAOc,iBAAiBV,EAAO,OAASA,EAAMW,aAEvFb,GACCc,YAAa,SAASb,GACrB,GAAIc,GAAO,UAAYd,EAAQ,wCAU/B,OAPIC,GAAMc,WACTd,EAAMc,WAAWC,QAAUF,EAE3Bb,EAAMgB,YAAcH,EAIC,QAAfR,EAAKY,QAKf,MAAO,UAASlB,GACf,OACCmB,QAASpB,EAAWc,YAAYb,GAAS,OACzCA,MAAOA,GAAS;;;;;AASnB,SAAWoB,EAAGC,EAAKC,GAElB,YAEA,SAASC,GAAOC,GAEQ,gBAAX5B,IAAiD,gBAAnBA,GAAOJ,QAEhDI,EAAOJ,QAAUgC,EACY,kBAAXC,SAAyBA,OAAOC,KAElDD,OAAQ,cAAe,WAAa,MAAOD,KAE1B,gBAANJ,KAEXA,EAAEI,YAAcA,GAiiBlB,QAASA,GAAaG,GACrB,GAAIC,GACHC,EACAC,EACAC,EACAC,EACAC,EAAUN,KAEXC,GAAWK,EAAQL,UAAYM,EAAGC,gBAGlC,KAAM,GAAIhD,GAAI,EAAGiD,EAAOR,EAASlC,OAAY0C,EAAJjD,EAAUA,IAOlD,GANA0C,EAAUD,EAAUzC,GACpB2C,EAASD,EAAQpB,WACjBsB,EAAaM,OACbL,EAAaK,OAG2B,QAAnCR,EAAQS,SAASC,gBAKhBV,EAASK,EAAGM,MACjBX,EAASK,EAAGM,QAMPP,EAAQQ,aAAcZ,EAASK,EAAGM,IAAKE,WAA7C,CAKA,GAAKZ,GAA4C,YAAlCA,EAAOQ,SAASC,eAa9B,GAVAL,EAAGS,gBAAiBb,GAKpBC,EAAaG,EAAGU,SAAUf,EAASC,GAK9BC,KAAe,EACnB,aAGDA,GAAaM,QAIPP,GAA4C,YAAlCA,EAAOQ,SAASC,gBAC9BL,EAAGW,gBAAoBhB,EAAQiB,QAAUC,EAASC,KAAMnB,EAAQiB,UAClEZ,EAAGe,YAAapB,GAGZE,GACJC,EAAaE,EAAGgB,iBAAkBnB,GAClCG,EAAGiB,mBAAoBnB,EAAYH,KAGnCG,EAAaE,EAAGgB,iBAAkBrB,IAEVQ,SAAnBR,EAAQiB,QAAwBjB,EAASK,EAAGM,IAAKM,SAErDZ,EAAGiB,mBAAoBnB,EAAYH,IAKrCA,EAASK,EAAGM,IAAKE,WAAY,GAS/B,QAASU,KAkBR,QAASC,KACLC,aAAaC,GACbA,EAAcC,WAAYC,EAAc,IAnB5CvB,EAAGwB,kBACHlC,GACA,IAWI+B,GAXAI,EAAaC,YAAa,WAK7B,MAFApC,KAEK,gBAAgBwB,KAAM3B,EAAIwC,gBAC9BC,eAAeH,GADhB,QAIE,KAGCF,EAAe,WACZjC,GAAciB,YAAY,IAO5BrB,GAAE2C,iBACN3C,EAAE2C,iBAAkB,SAAUV,GAAa,GAChCjC,EAAE4C,aACb5C,EAAE4C,YAAa,WAAYX,GA1oB7B,GAAKjC,EAAE6C,mBAEN,WADA1C,GAAO,aAKRF,GAAIlB,cAAe,UAGnB,IAAI+B,GAAKd,EAAEI,gBAEPuB,EAAW,mBAGfb,GAAGM,GAAK,cAGR,WACCN,EAAGgC,gBAAkB,UAAY5C,GACjCY,EAAGW,eAAiB,SAAWvB,GAC/BY,EAAGiC,gBAAkB,cAAgB7C,MAItCY,EAAGkC,KAAO,SAAUC,GACnB,MAAOA,GAAID,KAAOC,EAAID,OAASC,EAAIC,QAAS,aAAc,KAQ3DpC,EAAGqC,QAAU,WACZ,GAAIC,GAASnD,EAAIlB,cAAe,IAChC,OAAO,UAASsE,GAEf,MADAD,GAAOE,KAAOD,EACPD,EAAOE,SAOhBxC,EAAGyC,sBAAwB,WAC1B,MAA+B,WAAxBvD,EAAEwD,SAASC,UAMnB3C,EAAG4C,aAAe,SAAU9E,GAC3B,MAAOoB,GAAEtB,YAAcsB,EAAEtB,WAAYE,GAAQmB,SAI9Ce,EAAG6C,OAAS,WACX,MAAS3D,GAAE4D,kBAAoB,GAOhC9C,EAAG+C,mBAAqB,SAAUvF,GACjC,GAAIwF,EAEE,KAAOxF,GAAUA,EAAOyF,QAAS,KAAQ,KAAO,KAAWC,WAAY1F,GAAW,GAAKA,EAAOyF,QAAS,SAAY,IAC/G,OAAO,CASjBzF,GAASA,EAAO4E,QAAS,KAAM,KAGzBpC,EAAGmD,WACRnD,EAAGmD,SAAWhE,EAAIlB,cAAe,OAGjC+B,EAAGmD,SAASpF,MAAMe,QAAU,qGAG5BkB,EAAGmD,SAASC,UAAY,8BAGzBpD,EAAGmD,SAASpF,MAAMiB,MAAQ,KAEpB,KACFgB,EAAGmD,SAASpF,MAAMiB,MAAQxB,EACtB,MAAQhB,IAYhB,MAVA2C,GAAIkE,KAAKC,YAAYtD,EAAGmD,UAExBH,EAAWhD,EAAGmD,SAASI,YAEN,GAAZP,IACJA,GAAW,GAGZ7D,EAAIkE,KAAKG,YAAaxD,EAAGmD,UAElBH,GAGLhD,EAAGyD,kBAAoB,SAAUpF,EAAMqF,GAGnC,GAAItE,GAAQ,GAAIF,GAAEyE,KAWlB,OAVAvE,GAAMwE,QAAU,WACZ5D,EAAG6D,MAAOxF,IAAS,EACnBiB,KAEJF,EAAM0E,OAAS,WACX9D,EAAG6D,MAAOxF,GAAyB,IAAhBe,EAAMJ,MACzBM,KAEJF,EAAMmD,IAAMmB,EAEL,WAGd1D,EAAG6D,MAAQ7D,EAAG6D,UAEd7D,EAAGwB,gBAAkB,WAEdxB,EAAG6D,MAAO,eAAiB,EAC3B7D,EAAG6D,MAAO,cAAgB,EAC1B7D,EAAG6D,MAAO,cAAgB,EAC1B7D,EAAG6D,MAAO,iBAAoB1E,EAAI4E,eAAeC,WAAW,2CAA4C,OACxGhE,EAAG6D,MAAO,cAAiB7D,EAAGyD,kBAAkB,aAAc,gFAGrEzD,EAAGiE,kBAAoB,SAAUC,GAChC,GAAI7F,GAAO6F,EAAOC,aAAc,OAEhC,IAAc,OAAT9F,GAA0B,KAATA,EACrB,OAAO,CAEN,IAAI+F,GAASpE,EAAG6D,MAAOxF,EAExB,OAAuB,gBAAX+F,IAAkC,YAAXA,GAClCpE,EAAG6D,MAAOxF,GAAS2B,EAAGyD,kBAAmBpF,EAAM+F,GACxC,WACsB,kBAAXA,IAClBA,IACO,WAEAA,GAMVpE,EAAGqE,UAAY,SAAUC,GACxB,GAAIC,GAAQ,uBAAuBC,KAAMF,EACzC,QACCxG,MAAOyG,GAASA,EAAM,GACtB/G,OAAQ+G,GAASA,EAAM,KAKzBvE,EAAGyE,wBAA0B,SAAUC,GAMtC,IAAM,GAFLC,GADGC,EAAiB5E,EAAGkC,KAAMwC,GAAoBG,MAAO,WAG/C5H,EAAI,EAAG6H,EAAMF,EAAepH,OAAYsH,EAAJ7H,EAASA,IAAM,CAE5D,GAAI8H,GAAaH,EAAgB3H,GAEhC+H,EAAahF,EAAGqE,UAAWU,GAC3BvH,EAASwH,EAAWxH,OACpBM,EAAQkH,EAAWlH,KAEpB,IAAMN,KAICM,GAASkC,EAAG4C,aAAc9E,MAG/B6G,EAAgB3E,EAAG+C,mBAAoBvF,IACxC,MAKF,MAAOmH,IAAiBM,KAAKC,IAAIhG,EAAEiG,YAAc,EAAGhG,EAAIiG,gBAAgBC,cAGzErF,EAAGsF,YAAc,SAAU1E,GAa1B,IAFA,GAAId,MAEe,KAAXc,GAAgB,CACvBA,EAASA,EAAOwB,QAAS,QAAS,GAGlC,IACCmD,GADGC,EAAM5E,EAAO6E,OAAO,OAClBC,EAAa,IAEnB,IAAa,KAARF,EAAa,CACjBD,EAAM3E,EAAO+E,MAAO,EAAGH,EAEvB,IAAII,GAAOL,EAAII,MAAM,GAcrB,KARc,MAATC,GAAwB,KAARL,KACpBA,EAAMA,EAAInD,QAAS,MAAO,IAC1BsD,EAAa,IAEd9E,EAASA,EAAO+E,MAAOH,EAAM,GAIT,OAAfE,EAAsB,CAC1B,GAAIG,GAAUjF,EAAOqC,QAAS,IACb,MAAZ4C,GACJH,EAAa9E,EAAO+E,MAAO,EAAGE,GAC9BjF,EAASA,EAAO+E,MAAOE,EAAU,KAEjCH,EAAa9E,EACbA,EAAS,SAIX2E,GAAM3E,EACNA,EAAS,IAIL2E,GAAOG,IACX5F,EAAWgG,MACVP,IAAKA,EACLG,WAAYA,IAIf,MAAO5F,IAGRE,EAAG+F,gBAAkB,SAAUL,EAAYM,GAG1C,GAGCC,GAHGC,EAAQF,GAAa,QACxBG,EAAiBT,GAAcA,EAAWtD,QAAS,eAAgB,IACnEgE,EAAmBpG,EAAGyE,wBAAyByB,EAG/C,IAAKC,EAGJ,IAAK,GAFDE,GAAkBF,EAAetB,MAAM,KAElC5H,EAAIoJ,EAAgB7I,OAAS,EAAGP,GAAK,EAAGA,IAAK,CACrD,GAAIqJ,GAAOD,EAAiBpJ,GAC3BsJ,EAAWD,GAAQA,EAAKX,MAAOW,EAAK9I,OAAS,EAE9C,IAAoB,MAAb+I,GAAiC,MAAbA,GAAuBvG,EAAGW,gBAE9C,GAAkB,MAAb4F,EAAmB,CAC9B,GAAIC,GAAMF,GAAQpD,WAAYoD,EAAM,GACpCL,GAAeO,IAAQC,MAAOD,GAAQA,EAAM,OAH5CP,GAAe/C,WAAcwD,SAAUJ,EAAM,IAAOF,GAOxD,MAAOH,IAAgB,GAaxBjG,EAAG2G,2BAA6B,SAAU/F,EAAQsF,GAIjD,IAAM,GAHFpG,GAAaE,EAAGsF,YAAa1E,GAChCgG,KAES3J,EAAI,EAAG6H,EAAMhF,EAAWtC,OAAYsH,EAAJ7H,EAASA,IAAM,CACxD,GAAI4J,GAAY/G,EAAY7C,EAE5B2J,GAAoBd,MACnBP,IAAKsB,EAAUtB,IACfuB,WAAY9G,EAAG+F,gBAAiBc,EAAUnB,WAAYQ,KAGxD,MAAOU,IASR5G,EAAGe,YAAc,SAAUgG,GACrBA,EAAInG,SACRmG,EAAK/G,EAAGM,IAAKM,OAASmG,EAAInG,OAC1BmG,EAAInG,OAAS,GACbmG,EAAIC,aAAc,gBAAiBD,EAAK/G,EAAGM,IAAKM,UAKlDZ,EAAGgB,iBAAmB,SAAUiG,GAC/B,GAAIrG,GAASqG,EAAG9C,aAAc,UAC7B+B,EAAQe,EAAG9C,aAAc,SACzBrE,IAUD,OAPmC,QAA9BmH,EAAG7G,SAASC,eAA2B4G,EAAIjH,EAAGM,KAAQ2G,EAAIjH,EAAGM,IAAKM,SACtEA,EAASqG,EAAIjH,EAAGM,IAAKM,QAGjBA,IACJd,EAAaE,EAAG2G,2BAA4B/F,EAAQsF,IAE9CpG,GAGRE,EAAGkH,sBAAwB,SAAUC,GAEpC,GAAIpJ,GAAQoJ,EAAOpJ,UAClBqJ,EAA2B,4BAA8BrJ,GACzDsJ,EAActJ,EAAMuJ,IAEjBF,KACHrJ,EAAMuJ,KAAO,OAEbF,EAA2BD,EAAO5D,YAElCxF,EAAMuJ,KAAOD,IAIfrH,EAAGuH,iBAAmB,WACrB,GAAIC,MACAC,EAAU,SAAUN,EAAQnI,EAAOwH,GACxBxH,GACVmI,EAAOH,aAAc,QAASN,SAAS1H,EAAQwH,EAAK,KAGzD,OAAO,UAAUW,EAAQO,GACxB,GAAIX,EACEI,GAAQnH,EAAGM,MAAQpB,EAAEyI,sBAGGxH,SAAzBgH,EAAQnH,EAAGM,IAAKsH,OACpBT,EAAQnH,EAAGM,IAAIsH,KAAOT,EAAOhD,aAAa,UAAYgD,EAAOhD,aAAa,WAEtEgD,EAAQnH,EAAGM,IAAIsH,OAEfF,EAAcnC,MAAOiC,GACzBC,EAASN,EAAQK,EAASE,EAAcnC,KAAMmC,EAAcZ,aAE5DC,EAAM5H,EAAIlB,cAAe,OACzB8I,EAAIjD,OAAS,WAIG,GAHf0D,EAASE,EAAcnC,KAAOwB,EAAI/H,OAGbwI,EAASE,EAAcnC,KACzB,IACIpG,EAAIkE,KAAKC,YAAayD,GACtBS,EAASE,EAAcnC,KAAOwB,EAAI/H,OAAS+H,EAAIxD,YAC/CpE,EAAIkE,KAAKG,YAAauD,GACxB,MAAMvK,IAGtB2K,EAAO5E,MAAQmF,EAAcnC,KACjCkC,EAASN,EAAQK,EAASE,EAAcnC,KAAMmC,EAAcZ,YAE7DK,EAAS,KACTJ,EAAIjD,OAAS,KACbiD,EAAM,MAEPA,EAAIxE,IAAMmF,EAAcnC,WAK3BvF,EAAGiB,mBAAqB,SAAUnB,EAAYqH,GAC7C,GAAIN,GACHrJ,EACAkK,CAED5H,GAAW+H,KAAM7H,EAAG8H,eAEpBtK,EAASsC,EAAWtC,OACpBkK,EAAgB5H,EAAYtC,EAAS,EAErC,KAAM,GAAIP,GAAI,EAAOO,EAAJP,EAAYA,IAE5B,GADA4J,EAAY/G,EAAY7C,GACnB4J,EAAUC,YAAc9G,EAAG6C,SAAW,CAC1C6E,EAAgBb,CAChB,OAIGa,IAEJA,EAAcnC,IAAMvF,EAAGqC,QAASqF,EAAcnC,KAEzC4B,EAAO5E,MAAQmF,EAAcnC,MAC5BvF,EAAGyC,yBAAyF,UAA9DiF,EAAcnC,IAAIwC,OAAO,EAAG,QAAQvK,QAAQwK,cACtD7H,SAAnBxC,OAAOsK,SACXA,QAAQC,KAAM,+BAAiCR,EAAcnC,MAG9D4B,EAAO5E,IAAMmF,EAAcnC,IAGrBvF,EAAGiC,kBACRkF,EAAOgB,WAAahB,EAAO5E,KAG5BvC,EAAGkH,sBAAuBC,KAI5BnH,EAAGuH,iBAAiBJ,EAAQO,KAI9B1H,EAAG8H,cAAgB,SAAU/K,EAAGqL,GAC/B,MAAOrL,GAAE+J,WAAasB,EAAEtB,YAUzB9G,EAAGS,gBAAkB,SAAU4H,GAC9B,GAAIC,GAASD,EAAQlK,qBAAsB,QAC3C,IAAKmK,EAAO9K,OAAS,CAGpB,IAFA,GAAI+K,GAAQD,EAAQ,GACnBE,EAAWD,EAAMpK,qBAAsB,UAChCqK,EAAShL,QAChB6K,EAAQ7J,aAAcgK,EAAU,GAAKD,EAGtCA,GAAMhK,WAAWiF,YAAa+E,KAShCvI,EAAGC,eAAiB,WAInB,IAAM,GAHFwI,MACHC,EAAOvJ,EAAIhB,qBAAsB,OAExBwK,EAAI,EAAG7D,EAAM4D,EAAKlL,OAAYsH,EAAJ6D,EAASA,IAAM,CAClD,GAAIC,GAAUF,EAAMC,IAE+B,YAA9CC,EAAQrK,WAAW6B,SAASC,eACM,OAArCuI,EAAQzE,aAAc,WAAyByE,EAAS5I,EAAGM,KAAoC,OAA5BsI,EAAS5I,EAAGM,IAAKM,SACrF6H,EAAM3C,KAAM8C,GAGd,MAAOH,IAGRzI,EAAGU,SAAW,SAAUqG,EAAKsB,GAK5B,IAAM,GAHL9D,GADGsE,EAAUR,EAAQS,WAIZC,EAAI,EAAGC,EAAOH,EAAQrL,OAAYwL,EAAJD,EAAUA,IAAM,CACvD,GAAI7E,GAAS2E,EAASE,EAGtB,IAAyB,IAApB7E,EAAO+E,SAAZ,CAMA,GAAK/E,IAAW6C,EACf,MAAOxC,EAIR,IAAuC,WAAlCL,EAAO9D,SAASC,cAArB,CAIsC,OAAjC6D,EAAOC,aAAc,QAAuChE,eAAZ8H,UACpDA,QAAQC,KAAK,uFAGd,IAAIpK,GAAQoG,EAAOC,aAAc,QAGjC,IAAMD,EAAOC,aAAc,aAKnBrG,GAASkC,EAAG4C,aAAc9E,IAAY,CAC7C,GAAIoL,GAAgBlJ,EAAGiE,kBAAmBC,EAE1C,IAAKgF,KAAkB,EAAO,CAC7B3E,EAAQL,CACR,OACM,GAAuB,YAAlBgF,EACX,OAAO,KAKV,MAAO3E,IAqHRrD,IAGA5B,EAAY6J,EAAInJ,EAEhBX,EAAQC,IAEJ3B,OAAQA,OAAOK,SAAU,GAAIL,QAAOgG,YAEnCyF,GAAG,SAASpM,EAAQU,EAAOJ,GACjC,YAAmM,SAAS+L,GAAuBC,GAAM,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAA5Q,GAA6CG,IAA5BzM,EAAQ,gBAAmCA,EAAQ,yDAA6EqM,GAAuBI,KAElLC,eAAe,EAAEC,wDAAwD,IAAIC,GAAG,SAAS5M,EAAQU,EAAOJ,GAC3GI,EAAOJ,SACLuM,aACEC,MAAS,gCACTC,MAAS,gCACTC,QAAW,iCACXC,QAAS,oEAGF","file":"barvian.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/*! Picturefill - v2.3.1 - 2015-04-09\n* http://scottjehl.github.io/picturefill\n* Copyright (c) 2015 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT */\n/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */\n\nwindow.matchMedia || (window.matchMedia = function() {\n\t\"use strict\";\n\n\t// For browsers that support matchMedium api such as IE 9 and webkit\n\tvar styleMedia = (window.styleMedia || window.media);\n\n\t// For those that don't support matchMedium\n\tif (!styleMedia) {\n\t\tvar style       = document.createElement('style'),\n\t\t\tscript      = document.getElementsByTagName('script')[0],\n\t\t\tinfo        = null;\n\n\t\tstyle.type  = 'text/css';\n\t\tstyle.id    = 'matchmediajs-test';\n\n\t\tscript.parentNode.insertBefore(style, script);\n\n\t\t// 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers\n\t\tinfo = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;\n\n\t\tstyleMedia = {\n\t\t\tmatchMedium: function(media) {\n\t\t\t\tvar text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';\n\n\t\t\t\t// 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers\n\t\t\t\tif (style.styleSheet) {\n\t\t\t\t\tstyle.styleSheet.cssText = text;\n\t\t\t\t} else {\n\t\t\t\t\tstyle.textContent = text;\n\t\t\t\t}\n\n\t\t\t\t// Test if media query is true or false\n\t\t\t\treturn info.width === '1px';\n\t\t\t}\n\t\t};\n\t}\n\n\treturn function(media) {\n\t\treturn {\n\t\t\tmatches: styleMedia.matchMedium(media || 'all'),\n\t\t\tmedia: media || 'all'\n\t\t};\n\t};\n}());\n/*! Picturefill - Responsive Images that work today.\n*  Author: Scott Jehl, Filament Group, 2012 ( new proposal implemented by Shawn Jansepar )\n*  License: MIT/GPLv2\n*  Spec: http://picture.responsiveimages.org/\n*/\n(function( w, doc, image ) {\n\t// Enable strict mode\n\t\"use strict\";\n\n\tfunction expose(picturefill) {\n\t\t/* expose picturefill */\n\t\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\t\t// CommonJS, just export\n\t\t\tmodule.exports = picturefill;\n\t\t} else if ( typeof define === \"function\" && define.amd ) {\n\t\t\t// AMD support\n\t\t\tdefine( \"picturefill\", function() { return picturefill; } );\n\t\t}\n\t\tif ( typeof w === \"object\" ) {\n\t\t\t// If no AMD and we are in the browser, attach to window\n\t\t\tw.picturefill = picturefill;\n\t\t}\n\t}\n\n\t// If picture is supported, well, that's awesome. Let's get outta here...\n\tif ( w.HTMLPictureElement ) {\n\t\texpose(function() { });\n\t\treturn;\n\t}\n\n\t// HTML shim|v it for old IE (IE9 will still need the HTML video tag workaround)\n\tdoc.createElement( \"picture\" );\n\n\t// local object for method references and testing exposure\n\tvar pf = w.picturefill || {};\n\n\tvar regWDesc = /\\s+\\+?\\d+(e\\d+)?w/;\n\n\t// namespace\n\tpf.ns = \"picturefill\";\n\n\t// srcset support test\n\t(function() {\n\t\tpf.srcsetSupported = \"srcset\" in image;\n\t\tpf.sizesSupported = \"sizes\" in image;\n\t\tpf.curSrcSupported = \"currentSrc\" in image;\n\t})();\n\n\t// just a string trim workaround\n\tpf.trim = function( str ) {\n\t\treturn str.trim ? str.trim() : str.replace( /^\\s+|\\s+$/g, \"\" );\n\t};\n\n\t/**\n\t * Gets a string and returns the absolute URL\n\t * @param src\n\t * @returns {String} absolute URL\n\t */\n\tpf.makeUrl = (function() {\n\t\tvar anchor = doc.createElement( \"a\" );\n\t\treturn function(src) {\n\t\t\tanchor.href = src;\n\t\t\treturn anchor.href;\n\t\t};\n\t})();\n\n\t/**\n\t * Shortcut method for https://w3c.github.io/webappsec/specs/mixedcontent/#restricts-mixed-content ( for easy overriding in tests )\n\t */\n\tpf.restrictsMixedContent = function() {\n\t\treturn w.location.protocol === \"https:\";\n\t};\n\t/**\n\t * Shortcut method for matchMedia ( for easy overriding in tests )\n\t */\n\n\tpf.matchesMedia = function( media ) {\n\t\treturn w.matchMedia && w.matchMedia( media ).matches;\n\t};\n\n\t// Shortcut method for `devicePixelRatio` ( for easy overriding in tests )\n\tpf.getDpr = function() {\n\t\treturn ( w.devicePixelRatio || 1 );\n\t};\n\n\t/**\n\t * Get width in css pixel value from a \"length\" value\n\t * http://dev.w3.org/csswg/css-values-3/#length-value\n\t */\n\tpf.getWidthFromLength = function( length ) {\n\t\tvar cssValue;\n\t\t// If a length is specified and doesn’t contain a percentage, and it is greater than 0 or using `calc`, use it. Else, abort.\n        if ( !(length && length.indexOf( \"%\" ) > -1 === false && ( parseFloat( length ) > 0 || length.indexOf( \"calc(\" ) > -1 )) ) {\n            return false;\n        }\n\n\t\t/**\n\t\t * If length is specified in  `vw` units, use `%` instead since the div we’re measuring\n\t\t * is injected at the top of the document.\n\t\t *\n\t\t * TODO: maybe we should put this behind a feature test for `vw`? The risk of doing this is possible browser inconsistancies with vw vs %\n\t\t */\n\t\tlength = length.replace( \"vw\", \"%\" );\n\n\t\t// Create a cached element for getting length value widths\n\t\tif ( !pf.lengthEl ) {\n\t\t\tpf.lengthEl = doc.createElement( \"div\" );\n\n\t\t\t// Positioning styles help prevent padding/margin/width on `html` or `body` from throwing calculations off.\n\t\t\tpf.lengthEl.style.cssText = \"border:0;display:block;font-size:1em;left:0;margin:0;padding:0;position:absolute;visibility:hidden\";\n\n\t\t\t// Add a class, so that everyone knows where this element comes from\n\t\t\tpf.lengthEl.className = \"helper-from-picturefill-js\";\n\t\t}\n\n\t\tpf.lengthEl.style.width = \"0px\";\n\n        try {\n\t\t    pf.lengthEl.style.width = length;\n        } catch ( e ) {}\n\n\t\tdoc.body.appendChild(pf.lengthEl);\n\n\t\tcssValue = pf.lengthEl.offsetWidth;\n\n\t\tif ( cssValue <= 0 ) {\n\t\t\tcssValue = false;\n\t\t}\n\n\t\tdoc.body.removeChild( pf.lengthEl );\n\n\t\treturn cssValue;\n\t};\n\n    pf.detectTypeSupport = function( type, typeUri ) {\n        // based on Modernizr's lossless img-webp test\n        // note: asynchronous\n        var image = new w.Image();\n        image.onerror = function() {\n            pf.types[ type ] = false;\n            picturefill();\n        };\n        image.onload = function() {\n            pf.types[ type ] = image.width === 1;\n            picturefill();\n        };\n        image.src = typeUri;\n\n        return \"pending\";\n    };\n\t// container of supported mime types that one might need to qualify before using\n\tpf.types = pf.types || {};\n\n\tpf.initTypeDetects = function() {\n        // Add support for standard mime types\n        pf.types[ \"image/jpeg\" ] = true;\n        pf.types[ \"image/gif\" ] = true;\n        pf.types[ \"image/png\" ] = true;\n        pf.types[ \"image/svg+xml\" ] = doc.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#Image\", \"1.1\");\n        pf.types[ \"image/webp\" ] = pf.detectTypeSupport(\"image/webp\", \"data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=\");\n    };\n\n\tpf.verifyTypeSupport = function( source ) {\n\t\tvar type = source.getAttribute( \"type\" );\n\t\t// if type attribute exists, return test result, otherwise return true\n\t\tif ( type === null || type === \"\" ) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\t\tvar pfType = pf.types[ type ];\n\t\t\t// if the type test is a function, run it and return \"pending\" status. The function will rerun picturefill on pending elements once finished.\n\t\t\tif ( typeof pfType === \"string\" && pfType !== \"pending\") {\n\t\t\t\tpf.types[ type ] = pf.detectTypeSupport( type, pfType );\n\t\t\t\treturn \"pending\";\n\t\t\t} else if ( typeof pfType === \"function\" ) {\n\t\t\t\tpfType();\n\t\t\t\treturn \"pending\";\n\t\t\t} else {\n\t\t\t\treturn pfType;\n\t\t\t}\n\t\t}\n\t};\n\n\t// Parses an individual `size` and returns the length, and optional media query\n\tpf.parseSize = function( sourceSizeStr ) {\n\t\tvar match = /(\\([^)]+\\))?\\s*(.+)/g.exec( sourceSizeStr );\n\t\treturn {\n\t\t\tmedia: match && match[1],\n\t\t\tlength: match && match[2]\n\t\t};\n\t};\n\n\t// Takes a string of sizes and returns the width in pixels as a number\n\tpf.findWidthFromSourceSize = function( sourceSizeListStr ) {\n\t\t// Split up source size list, ie ( max-width: 30em ) 100%, ( max-width: 50em ) 50%, 33%\n\t\t//                            or (min-width:30em) calc(30% - 15px)\n\t\tvar sourceSizeList = pf.trim( sourceSizeListStr ).split( /\\s*,\\s*/ ),\n\t\t\twinningLength;\n\n\t\tfor ( var i = 0, len = sourceSizeList.length; i < len; i++ ) {\n\t\t\t// Match <media-condition>? length, ie ( min-width: 50em ) 100%\n\t\t\tvar sourceSize = sourceSizeList[ i ],\n\t\t\t\t// Split \"( min-width: 50em ) 100%\" into separate strings\n\t\t\t\tparsedSize = pf.parseSize( sourceSize ),\n\t\t\t\tlength = parsedSize.length,\n\t\t\t\tmedia = parsedSize.media;\n\n\t\t\tif ( !length ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// if there is no media query or it matches, choose this as our winning length\n\t\t\tif ( (!media || pf.matchesMedia( media )) &&\n\t\t\t\t// pass the length to a method that can properly determine length\n\t\t\t\t// in pixels based on these formats: http://dev.w3.org/csswg/css-values-3/#length-value\n\t\t\t\t(winningLength = pf.getWidthFromLength( length )) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t//if we have no winningLength fallback to 100vw\n\t\treturn winningLength || Math.max(w.innerWidth || 0, doc.documentElement.clientWidth);\n\t};\n\n\tpf.parseSrcset = function( srcset ) {\n\t\t/**\n\t\t * A lot of this was pulled from Boris Smus’ parser for the now-defunct WHATWG `srcset`\n\t\t * https://github.com/borismus/srcset-polyfill/blob/master/js/srcset-info.js\n\t\t *\n\t\t * 1. Let input (`srcset`) be the value passed to this algorithm.\n\t\t * 2. Let position be a pointer into input, initially pointing at the start of the string.\n\t\t * 3. Let raw candidates be an initially empty ordered list of URLs with associated\n\t\t *    unparsed descriptors. The order of entries in the list is the order in which entries\n\t\t *    are added to the list.\n\t\t */\n\t\tvar candidates = [];\n\n\t\twhile ( srcset !== \"\" ) {\n\t\t\tsrcset = srcset.replace( /^\\s+/g, \"\" );\n\n\t\t\t// 5. Collect a sequence of characters that are not space characters, and let that be url.\n\t\t\tvar pos = srcset.search(/\\s/g),\n\t\t\t\turl, descriptor = null;\n\n\t\t\tif ( pos !== -1 ) {\n\t\t\t\turl = srcset.slice( 0, pos );\n\n\t\t\t\tvar last = url.slice(-1);\n\n\t\t\t\t// 6. If url ends with a U+002C COMMA character (,), remove that character from url\n\t\t\t\t// and let descriptors be the empty string. Otherwise, follow these substeps\n\t\t\t\t// 6.1. If url is empty, then jump to the step labeled descriptor parser.\n\n\t\t\t\tif ( last === \",\" || url === \"\" ) {\n\t\t\t\t\turl = url.replace( /,+$/, \"\" );\n\t\t\t\t\tdescriptor = \"\";\n\t\t\t\t}\n\t\t\t\tsrcset = srcset.slice( pos + 1 );\n\n\t\t\t\t// 6.2. Collect a sequence of characters that are not U+002C COMMA characters (,), and\n\t\t\t\t// let that be descriptors.\n\t\t\t\tif ( descriptor === null ) {\n\t\t\t\t\tvar descpos = srcset.indexOf( \",\" );\n\t\t\t\t\tif ( descpos !== -1 ) {\n\t\t\t\t\t\tdescriptor = srcset.slice( 0, descpos );\n\t\t\t\t\t\tsrcset = srcset.slice( descpos + 1 );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdescriptor = srcset;\n\t\t\t\t\t\tsrcset = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\turl = srcset;\n\t\t\t\tsrcset = \"\";\n\t\t\t}\n\n\t\t\t// 7. Add url to raw candidates, associated with descriptors.\n\t\t\tif ( url || descriptor ) {\n\t\t\t\tcandidates.push({\n\t\t\t\t\turl: url,\n\t\t\t\t\tdescriptor: descriptor\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn candidates;\n\t};\n\n\tpf.parseDescriptor = function( descriptor, sizesattr ) {\n\t\t// 11. Descriptor parser: Let candidates be an initially empty source set. The order of entries in the list\n\t\t// is the order in which entries are added to the list.\n\t\tvar sizes = sizesattr || \"100vw\",\n\t\t\tsizeDescriptor = descriptor && descriptor.replace( /(^\\s+|\\s+$)/g, \"\" ),\n\t\t\twidthInCssPixels = pf.findWidthFromSourceSize( sizes ),\n\t\t\tresCandidate;\n\n\t\t\tif ( sizeDescriptor ) {\n\t\t\t\tvar splitDescriptor = sizeDescriptor.split(\" \");\n\n\t\t\t\tfor (var i = splitDescriptor.length - 1; i >= 0; i--) {\n\t\t\t\t\tvar curr = splitDescriptor[ i ],\n\t\t\t\t\t\tlastchar = curr && curr.slice( curr.length - 1 );\n\n\t\t\t\t\tif ( ( lastchar === \"h\" || lastchar === \"w\" ) && !pf.sizesSupported ) {\n\t\t\t\t\t\tresCandidate = parseFloat( ( parseInt( curr, 10 ) / widthInCssPixels ) );\n\t\t\t\t\t} else if ( lastchar === \"x\" ) {\n\t\t\t\t\t\tvar res = curr && parseFloat( curr, 10 );\n\t\t\t\t\t\tresCandidate = res && !isNaN( res ) ? res : 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\treturn resCandidate || 1;\n\t};\n\n\t/**\n\t * Takes a srcset in the form of url/\n\t * ex. \"images/pic-medium.png 1x, images/pic-medium-2x.png 2x\" or\n\t *     \"images/pic-medium.png 400w, images/pic-medium-2x.png 800w\" or\n\t *     \"images/pic-small.png\"\n\t * Get an array of image candidates in the form of\n\t *      {url: \"/foo/bar.png\", resolution: 1}\n\t * where resolution is http://dev.w3.org/csswg/css-values-3/#resolution-value\n\t * If sizes is specified, resolution is calculated\n\t */\n\tpf.getCandidatesFromSourceSet = function( srcset, sizes ) {\n\t\tvar candidates = pf.parseSrcset( srcset ),\n\t\t\tformattedCandidates = [];\n\n\t\tfor ( var i = 0, len = candidates.length; i < len; i++ ) {\n\t\t\tvar candidate = candidates[ i ];\n\n\t\t\tformattedCandidates.push({\n\t\t\t\turl: candidate.url,\n\t\t\t\tresolution: pf.parseDescriptor( candidate.descriptor, sizes )\n\t\t\t});\n\t\t}\n\t\treturn formattedCandidates;\n\t};\n\n\t/**\n\t * if it's an img element and it has a srcset property,\n\t * we need to remove the attribute so we can manipulate src\n\t * (the property's existence infers native srcset support, and a srcset-supporting browser will prioritize srcset's value over our winning picture candidate)\n\t * this moves srcset's value to memory for later use and removes the attr\n\t */\n\tpf.dodgeSrcset = function( img ) {\n\t\tif ( img.srcset ) {\n\t\t\timg[ pf.ns ].srcset = img.srcset;\n\t\t\timg.srcset = \"\";\n\t\t\timg.setAttribute( \"data-pfsrcset\", img[ pf.ns ].srcset );\n\t\t}\n\t};\n\n\t// Accept a source or img element and process its srcset and sizes attrs\n\tpf.processSourceSet = function( el ) {\n\t\tvar srcset = el.getAttribute( \"srcset\" ),\n\t\t\tsizes = el.getAttribute( \"sizes\" ),\n\t\t\tcandidates = [];\n\n\t\t// if it's an img element, use the cached srcset property (defined or not)\n\t\tif ( el.nodeName.toUpperCase() === \"IMG\" && el[ pf.ns ] && el[ pf.ns ].srcset ) {\n\t\t\tsrcset = el[ pf.ns ].srcset;\n\t\t}\n\n\t\tif ( srcset ) {\n\t\t\tcandidates = pf.getCandidatesFromSourceSet( srcset, sizes );\n\t\t}\n\t\treturn candidates;\n\t};\n\n\tpf.backfaceVisibilityFix = function( picImg ) {\n\t\t// See: https://github.com/scottjehl/picturefill/issues/332\n\t\tvar style = picImg.style || {},\n\t\t\tWebkitBackfaceVisibility = \"webkitBackfaceVisibility\" in style,\n\t\t\tcurrentZoom = style.zoom;\n\n\t\tif (WebkitBackfaceVisibility) {\n\t\t\tstyle.zoom = \".999\";\n\n\t\t\tWebkitBackfaceVisibility = picImg.offsetWidth;\n\n\t\t\tstyle.zoom = currentZoom;\n\t\t}\n\t};\n\n\tpf.setIntrinsicSize = (function() {\n\t\tvar urlCache = {};\n\t\tvar setSize = function( picImg, width, res ) {\n            if ( width ) {\n\t\t\t    picImg.setAttribute( \"width\", parseInt(width / res, 10) );\n            }\n\t\t};\n\t\treturn function( picImg, bestCandidate ) {\n\t\t\tvar img;\n\t\t\tif ( !picImg[ pf.ns ] || w.pfStopIntrinsicSize ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( picImg[ pf.ns ].dims === undefined ) {\n\t\t\t\tpicImg[ pf.ns].dims = picImg.getAttribute(\"width\") || picImg.getAttribute(\"height\");\n\t\t\t}\n\t\t\tif ( picImg[ pf.ns].dims ) { return; }\n\n\t\t\tif ( bestCandidate.url in urlCache ) {\n\t\t\t\tsetSize( picImg, urlCache[bestCandidate.url], bestCandidate.resolution );\n\t\t\t} else {\n\t\t\t\timg = doc.createElement( \"img\" );\n\t\t\t\timg.onload = function() {\n\t\t\t\t\turlCache[bestCandidate.url] = img.width;\n\n                    //IE 10/11 don't calculate width for svg outside document\n                    if ( !urlCache[bestCandidate.url] ) {\n                        try {\n                            doc.body.appendChild( img );\n                            urlCache[bestCandidate.url] = img.width || img.offsetWidth;\n                            doc.body.removeChild( img );\n                        } catch(e){}\n                    }\n\n\t\t\t\t\tif ( picImg.src === bestCandidate.url ) {\n\t\t\t\t\t\tsetSize( picImg, urlCache[bestCandidate.url], bestCandidate.resolution );\n\t\t\t\t\t}\n\t\t\t\t\tpicImg = null;\n\t\t\t\t\timg.onload = null;\n\t\t\t\t\timg = null;\n\t\t\t\t};\n\t\t\t\timg.src = bestCandidate.url;\n\t\t\t}\n\t\t};\n\t})();\n\n\tpf.applyBestCandidate = function( candidates, picImg ) {\n\t\tvar candidate,\n\t\t\tlength,\n\t\t\tbestCandidate;\n\n\t\tcandidates.sort( pf.ascendingSort );\n\n\t\tlength = candidates.length;\n\t\tbestCandidate = candidates[ length - 1 ];\n\n\t\tfor ( var i = 0; i < length; i++ ) {\n\t\t\tcandidate = candidates[ i ];\n\t\t\tif ( candidate.resolution >= pf.getDpr() ) {\n\t\t\t\tbestCandidate = candidate;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( bestCandidate ) {\n\n\t\t\tbestCandidate.url = pf.makeUrl( bestCandidate.url );\n\n\t\t\tif ( picImg.src !== bestCandidate.url ) {\n\t\t\t\tif ( pf.restrictsMixedContent() && bestCandidate.url.substr(0, \"http:\".length).toLowerCase() === \"http:\" ) {\n\t\t\t\t\tif ( window.console !== undefined ) {\n\t\t\t\t\t\tconsole.warn( \"Blocked mixed content image \" + bestCandidate.url );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpicImg.src = bestCandidate.url;\n\t\t\t\t\t// currentSrc attribute and property to match\n\t\t\t\t\t// http://picture.responsiveimages.org/#the-img-element\n\t\t\t\t\tif ( !pf.curSrcSupported ) {\n\t\t\t\t\t\tpicImg.currentSrc = picImg.src;\n\t\t\t\t\t}\n\n\t\t\t\t\tpf.backfaceVisibilityFix( picImg );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpf.setIntrinsicSize(picImg, bestCandidate);\n\t\t}\n\t};\n\n\tpf.ascendingSort = function( a, b ) {\n\t\treturn a.resolution - b.resolution;\n\t};\n\n\t/**\n\t * In IE9, <source> elements get removed if they aren't children of\n\t * video elements. Thus, we conditionally wrap source elements\n\t * using <!--[if IE 9]><video style=\"display: none;\"><![endif]-->\n\t * and must account for that here by moving those source elements\n\t * back into the picture element.\n\t */\n\tpf.removeVideoShim = function( picture ) {\n\t\tvar videos = picture.getElementsByTagName( \"video\" );\n\t\tif ( videos.length ) {\n\t\t\tvar video = videos[ 0 ],\n\t\t\t\tvsources = video.getElementsByTagName( \"source\" );\n\t\t\twhile ( vsources.length ) {\n\t\t\t\tpicture.insertBefore( vsources[ 0 ], video );\n\t\t\t}\n\t\t\t// Remove the video element once we're finished removing its children\n\t\t\tvideo.parentNode.removeChild( video );\n\t\t}\n\t};\n\n\t/**\n\t * Find all `img` elements, and add them to the candidate list if they have\n\t * a `picture` parent, a `sizes` attribute in basic `srcset` supporting browsers,\n\t * a `srcset` attribute at all, and they haven’t been evaluated already.\n\t */\n\tpf.getAllElements = function() {\n\t\tvar elems = [],\n\t\t\timgs = doc.getElementsByTagName( \"img\" );\n\n\t\tfor ( var h = 0, len = imgs.length; h < len; h++ ) {\n\t\t\tvar currImg = imgs[ h ];\n\n\t\t\tif ( currImg.parentNode.nodeName.toUpperCase() === \"PICTURE\" ||\n\t\t\t( currImg.getAttribute( \"srcset\" ) !== null ) || currImg[ pf.ns ] && currImg[ pf.ns ].srcset !== null ) {\n\t\t\t\telems.push( currImg );\n\t\t\t}\n\t\t}\n\t\treturn elems;\n\t};\n\n\tpf.getMatch = function( img, picture ) {\n\t\tvar sources = picture.childNodes,\n\t\t\tmatch;\n\n\t\t// Go through each child, and if they have media queries, evaluate them\n\t\tfor ( var j = 0, slen = sources.length; j < slen; j++ ) {\n\t\t\tvar source = sources[ j ];\n\n\t\t\t// ignore non-element nodes\n\t\t\tif ( source.nodeType !== 1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Hitting the `img` element that started everything stops the search for `sources`.\n\t\t\t// If no previous `source` matches, the `img` itself is evaluated later.\n\t\t\tif ( source === img ) {\n\t\t\t\treturn match;\n\t\t\t}\n\n\t\t\t// ignore non-`source` nodes\n\t\t\tif ( source.nodeName.toUpperCase() !== \"SOURCE\" ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// if it's a source element that has the `src` property set, throw a warning in the console\n\t\t\tif ( source.getAttribute( \"src\" ) !== null && typeof console !== undefined ) {\n\t\t\t\tconsole.warn(\"The `src` attribute is invalid on `picture` `source` element; instead, use `srcset`.\");\n\t\t\t}\n\n\t\t\tvar media = source.getAttribute( \"media\" );\n\n\t\t\t// if source does not have a srcset attribute, skip\n\t\t\tif ( !source.getAttribute( \"srcset\" ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// if there's no media specified, OR w.matchMedia is supported\n\t\t\tif ( ( !media || pf.matchesMedia( media ) ) ) {\n\t\t\t\tvar typeSupported = pf.verifyTypeSupport( source );\n\n\t\t\t\tif ( typeSupported === true ) {\n\t\t\t\t\tmatch = source;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if ( typeSupported === \"pending\" ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn match;\n\t};\n\n\tfunction picturefill( opt ) {\n\t\tvar elements,\n\t\t\telement,\n\t\t\tparent,\n\t\t\tfirstMatch,\n\t\t\tcandidates,\n\t\t\toptions = opt || {};\n\n\t\telements = options.elements || pf.getAllElements();\n\n\t\t// Loop through all elements\n\t\tfor ( var i = 0, plen = elements.length; i < plen; i++ ) {\n\t\t\telement = elements[ i ];\n\t\t\tparent = element.parentNode;\n\t\t\tfirstMatch = undefined;\n\t\t\tcandidates = undefined;\n\n\t\t\t// immediately skip non-`img` nodes\n\t\t\tif ( element.nodeName.toUpperCase() !== \"IMG\" ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// expando for caching data on the img\n\t\t\tif ( !element[ pf.ns ] ) {\n\t\t\t\telement[ pf.ns ] = {};\n\t\t\t}\n\n\t\t\t// if the element has already been evaluated, skip it unless\n\t\t\t// `options.reevaluate` is set to true ( this, for example,\n\t\t\t// is set to true when running `picturefill` on `resize` ).\n\t\t\tif ( !options.reevaluate && element[ pf.ns ].evaluated ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// if `img` is in a `picture` element\n\t\t\tif ( parent && parent.nodeName.toUpperCase() === \"PICTURE\" ) {\n\n\t\t\t\t// IE9 video workaround\n\t\t\t\tpf.removeVideoShim( parent );\n\n\t\t\t\t// return the first match which might undefined\n\t\t\t\t// returns false if there is a pending source\n\t\t\t\t// TODO the return type here is brutal, cleanup\n\t\t\t\tfirstMatch = pf.getMatch( element, parent );\n\n\t\t\t\t// if any sources are pending in this picture due to async type test(s)\n\t\t\t\t// remove the evaluated attr and skip for now ( the pending test will\n\t\t\t\t// rerun picturefill on this element when complete)\n\t\t\t\tif ( firstMatch === false ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfirstMatch = undefined;\n\t\t\t}\n\n\t\t\t// Cache and remove `srcset` if present and we’re going to be doing `picture`/`srcset`/`sizes` polyfilling to it.\n\t\t\tif ( ( parent && parent.nodeName.toUpperCase() === \"PICTURE\" ) ||\n\t\t\t( !pf.sizesSupported && ( element.srcset && regWDesc.test( element.srcset ) ) ) ) {\n\t\t\t\tpf.dodgeSrcset( element );\n\t\t\t}\n\n\t\t\tif ( firstMatch ) {\n\t\t\t\tcandidates = pf.processSourceSet( firstMatch );\n\t\t\t\tpf.applyBestCandidate( candidates, element );\n\t\t\t} else {\n\t\t\t\t// No sources matched, so we’re down to processing the inner `img` as a source.\n\t\t\t\tcandidates = pf.processSourceSet( element );\n\n\t\t\t\tif ( element.srcset === undefined || element[ pf.ns ].srcset ) {\n\t\t\t\t\t// Either `srcset` is completely unsupported, or we need to polyfill `sizes` functionality.\n\t\t\t\t\tpf.applyBestCandidate( candidates, element );\n\t\t\t\t} // Else, resolution-only `srcset` is supported natively.\n\t\t\t}\n\n\t\t\t// set evaluated to true to avoid unnecessary reparsing\n\t\t\telement[ pf.ns ].evaluated = true;\n\t\t}\n\t}\n\n\t/**\n\t * Sets up picture polyfill by polling the document and running\n\t * the polyfill every 250ms until the document is ready.\n\t * Also attaches picturefill on resize\n\t */\n\tfunction runPicturefill() {\n\t\tpf.initTypeDetects();\n\t\tpicturefill();\n\t\tvar intervalId = setInterval( function() {\n\t\t\t// When the document has finished loading, stop checking for new images\n\t\t\t// https://github.com/ded/domready/blob/master/ready.js#L15\n\t\t\tpicturefill();\n\n\t\t\tif ( /^loaded|^i|^c/.test( doc.readyState ) ) {\n\t\t\t\tclearInterval( intervalId );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}, 250 );\n\n\t\tvar resizeTimer;\n\t\tvar handleResize = function() {\n\t        picturefill({ reevaluate: true });\n\t    };\n\t\tfunction checkResize() {\n\t\t    clearTimeout(resizeTimer);\n\t\t    resizeTimer = setTimeout( handleResize, 60 );\n\t\t}\n\n\t\tif ( w.addEventListener ) {\n\t\t\tw.addEventListener( \"resize\", checkResize, false );\n\t\t} else if ( w.attachEvent ) {\n\t\t\tw.attachEvent( \"onresize\", checkResize );\n\t\t}\n\t}\n\n\trunPicturefill();\n\n\t/* expose methods for testing */\n\tpicturefill._ = pf;\n\n\texpose( picturefill );\n\n} )( window, window.document, new window.Image() );\n\n},{}],2:[function(require,module,exports){\n'use strict';var _variables = require('../variables');var _picturefill = require(\"./../bower_components/picturefill/dist/picturefill.js\");var _picturefill2 = _interopRequireDefault(_picturefill);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}\n\n},{\"../variables\":3,\"./../bower_components/picturefill/dist/picturefill.js\":1}],3:[function(require,module,exports){\nmodule.exports={\n  \"breakpoints\": {\n    \"alpha\": \"screen and (min-width: 560px)\",\n    \"bravo\": \"screen and (min-width: 780px)\",\n    \"charlie\": \"screen and (min-width: 1240px)\",\n    \"short\": \"screen and (min-width: 780px) and (max-height: 740px)\"\n  }\n}\n},{}]},{},[2]);\n"],"sourceRoot":"/source/"}